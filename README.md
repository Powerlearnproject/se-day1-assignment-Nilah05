[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18392126&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the process of designing, building, testing and maintaining computer programs in a structured way.it follows rules and methods to makesure software works well is reliable and meeets user needs
it's importance is;
Creates reliable software: ensures programs work correctly and don't crash
Saves time and money: helps develop software efficiently reducing errors and costs
Improves security: protects data from hackers and cyber threats
Enables innovations and support businesses

Identify and describe at least three key milestones in the evolution of software engineering.
1.Introduction of programming languages:
earlier people wrote software using machine code(0s and 1s) which was very hard, thus high level languages like fortrain and cobol were created to make coding easier and faster.
2. Structured programming
before structured programming, software was written in an unorganized way, leading to errors and difficultues in fixing problems, thus this approach introduced clear rules for writting software making it easy to read, debug and maintain, language like c and pascal became popular during this time.
3. Agile development and modern software engineering
traditional methods were slow and rigid making it hard to adapt to changes, thus agike development introduced faster, flexible and team work based software creation. currently software is built in small steps with continous feedback making it more reliable and user friendly



List and briefly explain the phases of the Software Development Life Cycle.
1. Planning
decides what the software should do and why it is neeeded. identify risks, costs, and time required.
2. Requirements gathering
Talk to users and stakeholders to understand what they need.write down features and functions software must have
3. Design
plan how software will look and work, create diagrams and models to guide development
4. Coding
programmers write the actual software code, they use programming languages to turn the design into a working system
5. Testing
Check the errors and bugs in software, make sure everything works as expected before releasing it
6. Deployment
release software to the users, it can be installed on computers, servers, or made available online
7. Maintainance
fix issues, update features, and improve performance over time, ensures software remains useful and secure.



Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
The methodologies would be compared based on the following features
PROCESS: water fall methodology involves step by step where each phase is completed before moving to the next
         agile methodology is flexible and work is done in small cycles
FLEXIBILITY:  water fall methodology it is hard to change once a phase is completed
              agile methodology easy to make changes
SPEED:  water fall methodology is slower takes more time to finish
         agile methodology is faster delivers small parts quickly
USER INVOLVEMENT: water fall methodology users see the product only at the end
                   agile methodology users gives feedback throughout the process
EXAMPLE OF SCENARIOS
Waterfall methodology example is building a banking system 
a bank wants a secure and well planned system for handling transactions, requirements are clear and must follow strict rules, waterfall is best because chnges later could be costly and risky.
Agile methodology example is developing mobile application
a company needs to create new social media app, user need and trends keep changing, so updates are needed often, agile is better cause it allows continous improvements and fast updates.
              
         

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
SOFTWARE DEVELOPER ( The builder)
writes code to create software, follows design plan and fixes bugs, work with other team members ro add new features.
QUALITY ASSURANCE ENGINEER ( The tester)
checks software for errors and bugs, make sure evrything works correctly and meet user needs, helps improve software quality before it is released.
PROJECT MANAGER (The organizer)
plans the project, sets deadlines and manages team, communicates with clients and team members, solve problems and ensures the project is completed on time.



Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs: is a software tool that help developers write,test and debug code more easily. it includes features like a text editor, compiler and debbuging tools in one place
it helps in speeding up coding, reducing errors and improves productivity
examples: visual studio code, eclipse, pycharm.

VCS: keeps track of changes made to the code overtime . it allows multiple developers to work on the same project without loosing progress
it helps to track changes, support team work and prevents data loss
examples: git, dubvrsion, mercurial



What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Debugging and fixing bugs
challenge: software often has errors that can be hard to find and fix
solution: use debugging tools, write clean code and test regularly to catch bugs early

Meeting deadlines
challenge: project can take longer than expected causing delays
solution: plan properly, breakn tasks into smaller parts and use project management tools

Keeping up with new technologies
challenge:technology changes faster and new tools keep coming
solution: keep learning by reading articles, taking online courses, and practising new skills.



Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
UNIT TESTING
tests individual parts of the software like function or module. This helps to find bugs early and make sure each part wok properly
example: testing a login function separately before combining it with other parts

INTERGRATION TESTING
Tests the entire software as a complete system, this helps to find problem when combining different modules
example: testing if login function correctly connects to the database

SYSTEM TESTING
tests the entire software as complete system, this ensures the whole software works as expected before releases
example: checking if a banking app can handle deposits, withdrawals and transfers smoothly.

ACCEPTANCE TESTING
tests if the software meets user need and business requirements, this helps to ensure the software is ready for real users.
example: kletting a customer test an e-commerce website before launching it.



#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
prompt engineering: is the skill of writting clear and specific instructions to get best answers from an AI model. it helps AI to understand exactly what you need.
IMPORTANCE
Improves accuracy: a well written prompt gives more useful and correct answers
Saves time: clear prompts reduce the need for asking again or fixing mistakes
Enhances creativity: Helps AI generate better ideas, content or solutions

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague prompt: "tell me about technology" ( this is to broad-unclear hich aspect of technology is needed)
Improved prompt: "explain how artificial intelligence is changing healthcare  industry in simple words" ( this is clear, concise, and specific)
The improved prompt helps the AI focus on particular topic, making response more useful an relevant.
